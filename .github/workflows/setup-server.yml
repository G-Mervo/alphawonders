name: Setup New EC2 Server

# Manual trigger — run once per new server
on:
  workflow_dispatch:
    inputs:
      instance_id:
        description: 'EC2 Instance ID (e.g. i-0abc123)'
        required: true
      deploy_home:
        description: 'Deploy user home dir (e.g. /home/ec2-user)'
        required: true

env:
  REGISTRY: ghcr.io

jobs:
  setup:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # ── Step 1: Store secrets in Parameter Store ──
      - name: Store secrets in SSM Parameter Store
        env:
          GHCR_PAT_VALUE: ${{ vars.GHCR_PAT }}
          PG_PASSWORD_VALUE: ${{ vars.PG_PASSWORD }}
          PG_USER_VALUE: ${{ vars.PG_USER }}
          PG_DB_VALUE: ${{ vars.PG_DB }}
        run: |
          REGION="${{ secrets.AWS_REGION }}"

          store_param() {
            local name="$1" value="$2" desc="$3" type="${4:-SecureString}"
            if [ -z "$value" ]; then
              echo "WARNING: $name is empty, skipping"
              return
            fi
            aws ssm put-parameter \
              --name "$name" \
              --type "$type" \
              --value "$value" \
              --description "$desc" \
              --region "$REGION" \
              --overwrite
            echo "$name — stored"
          }

          # All values from repo variables (passed via env for safe shell escaping)
          store_param "/deploy/ghcr-pat"         "$GHCR_PAT_VALUE"       "GHCR PAT for docker pull"
          store_param "/deploy/pg-password"      "$PG_PASSWORD_VALUE"    "PostgreSQL password"
          store_param "/deploy/pg-user"          "$PG_USER_VALUE"        "PostgreSQL username"             String
          store_param "/deploy/pg-db"            "$PG_DB_VALUE"          "PostgreSQL database name"        String

      # ── Step 2: Package infra files ──
      - name: Package infra files
        run: |
          tar czf /tmp/infra-bundle.tar.gz \
            infra/docker-compose.postgres.yml \
            infra/nginx/ \
            docker-compose.yml
          echo "Bundle size: $(wc -c < /tmp/infra-bundle.tar.gz) bytes"

      # ── Step 3: Install Docker via SSM ──
      - name: Install Docker on EC2
        env:
          INSTANCE_ID: ${{ inputs.instance_id }}
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Install Docker" \
            --timeout-seconds 300 \
            --parameters commands="[
              \"set -e\",
              \"echo '── Installing Docker ──'\",
              \"if ! command -v docker &>/dev/null; then dnf update -y && dnf install -y docker && systemctl enable --now docker && usermod -aG docker ec2-user; else echo 'Docker already installed'; fi\",
              \"echo '── Installing Docker Compose plugin ──'\",
              \"mkdir -p /usr/local/lib/docker/cli-plugins /root/.docker/cli-plugins\",
              \"ARCH=\$(uname -m); if [ \\\"\$ARCH\\\" = 'aarch64' ]; then ARCH='aarch64'; else ARCH='x86_64'; fi\",
              \"if ! docker compose version &>/dev/null; then curl -SL https://github.com/docker/compose/releases/latest/download/docker-compose-linux-\$ARCH -o /usr/local/lib/docker/cli-plugins/docker-compose && chmod +x /usr/local/lib/docker/cli-plugins/docker-compose; else echo 'Compose already installed'; fi\",
              \"ln -sf /usr/local/lib/docker/cli-plugins/docker-compose /root/.docker/cli-plugins/docker-compose 2>/dev/null || true\",
              \"docker --version\",
              \"docker compose version\"
            ]" \
            --output text --query 'Command.CommandId')

          echo "SSM Command ID: $COMMAND_ID"
          echo "Waiting for Docker install..."
          for i in $(seq 1 60); do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query Status --output text 2>/dev/null || echo "Pending")
            if [ "$STATUS" != "InProgress" ] && [ "$STATUS" != "Pending" ]; then
              break
            fi
            echo "  [$i/60] Status: $STATUS"
            sleep 5
          done

          RESULT=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --output json)
          STATUS=$(echo "$RESULT" | jq -r '.Status')
          echo "Status: $STATUS"
          echo "$RESULT" | jq -r '.StandardOutputContent'
          if [ "$STATUS" != "Success" ]; then
            echo "$RESULT" | jq -r '.StandardErrorContent'
            exit 1
          fi

      # ── Step 4: Transfer infra files via SSM ──
      - name: Transfer infra files to EC2
        env:
          INSTANCE_ID: ${{ inputs.instance_id }}
          HOME_DIR: ${{ inputs.deploy_home }}
        run: |
          BUNDLE=$(base64 -w0 /tmp/infra-bundle.tar.gz)

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Transfer infra files" \
            --timeout-seconds 120 \
            --parameters commands="[
              \"set -e\",
              \"mkdir -p ${HOME_DIR}/infra ${HOME_DIR}/alphawonders\",
              \"echo '$BUNDLE' | base64 -d > /tmp/infra-bundle.tar.gz\",
              \"mkdir -p /tmp/infra-extract && tar xzf /tmp/infra-bundle.tar.gz -C /tmp/infra-extract\",
              \"cp -r /tmp/infra-extract/infra/* ${HOME_DIR}/infra/\",
              \"cp /tmp/infra-extract/docker-compose.yml ${HOME_DIR}/alphawonders/docker-compose.yml\",
              \"rm -rf /tmp/infra-bundle.tar.gz /tmp/infra-extract\",
              \"chown -R ec2-user:ec2-user ${HOME_DIR}/infra ${HOME_DIR}/alphawonders\",
              \"echo '── Files deployed ──'\",
              \"ls -la ${HOME_DIR}/infra/\",
              \"ls -la ${HOME_DIR}/infra/nginx/conf.d/\",
              \"ls -la ${HOME_DIR}/alphawonders/\"
            ]" \
            --output text --query 'Command.CommandId')

          echo "SSM Command ID: $COMMAND_ID"
          echo "Waiting for file transfer..."
          for i in $(seq 1 30); do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query Status --output text 2>/dev/null || echo "Pending")
            if [ "$STATUS" != "InProgress" ] && [ "$STATUS" != "Pending" ]; then
              break
            fi
            echo "  [$i/30] Status: $STATUS"
            sleep 5
          done

          RESULT=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --output json)
          STATUS=$(echo "$RESULT" | jq -r '.Status')
          echo "Status: $STATUS"
          echo "$RESULT" | jq -r '.StandardOutputContent'
          if [ "$STATUS" != "Success" ]; then
            echo "$RESULT" | jq -r '.StandardErrorContent'
            exit 1
          fi

      # ── Step 5: Start everything ──
      - name: Start infrastructure and app
        env:
          INSTANCE_ID: ${{ inputs.instance_id }}
          HOME_DIR: ${{ inputs.deploy_home }}
          IMAGE: ghcr.io/g-mervo/alphawonders:latest
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Start infra + app" \
            --timeout-seconds 600 \
            --parameters commands="[
              \"set -e\",
              \"TOKEN=\$(curl -sX PUT http://169.254.169.254/latest/api/token -H 'X-aws-ec2-metadata-token-ttl-seconds: 60')\",
              \"REGION=\$(curl -s -H \\\"X-aws-ec2-metadata-token: \$TOKEN\\\" http://169.254.169.254/latest/meta-data/placement/region)\",
              \"echo \\\"Region: \$REGION\\\"\",
              \"get_param() { aws ssm get-parameter --name \\\"\$1\\\" --with-decryption --query Parameter.Value --output text --region \\\"\$REGION\\\" 2>/dev/null || echo ''; }\",
              \"echo '── GHCR login ──'\",
              \"GHCR_PAT=\$(get_param /deploy/ghcr-pat)\",
              \"if [ -n \\\"\$GHCR_PAT\\\" ]; then echo \\\"\$GHCR_PAT\\\" | docker login ghcr.io -u deploy --password-stdin; fi\",
              \"echo '── Load secrets ──'\",
              \"export PG_USER=\$(get_param /deploy/pg-user)\",
              \"export PG_PASSWORD=\$(get_param /deploy/pg-password)\",
              \"export PG_DB=\$(get_param /deploy/pg-db)\",
              \"export DB_USERNAME=\$PG_USER\",
              \"export DB_PASSWORD=\$PG_PASSWORD\",
              \"export DB_DATABASE=\$PG_DB\",
              \"echo \\\"PG_USER=[\$PG_USER] PG_DB=[\$PG_DB] PG_PASSWORD_LENGTH=[\${#PG_PASSWORD}]\\\"\",
              \"echo '── Clean up old containers (safe for fresh setup) ──'\",
              \"cd ${HOME_DIR}/infra\",
              \"docker compose -f docker-compose.postgres.yml down -v 2>/dev/null || true\",
              \"cd ${HOME_DIR}/alphawonders\",
              \"docker compose down -v 2>/dev/null || true\",
              \"echo '── Start PostgreSQL + Nginx ──'\",
              \"cd ${HOME_DIR}/infra\",
              \"docker compose -f docker-compose.postgres.yml up -d\",
              \"echo 'Waiting for PostgreSQL...'\",
              \"for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30; do if docker inspect --format='{{.State.Health.Status}}' postgres 2>/dev/null | grep -q healthy; then echo 'PostgreSQL healthy!'; break; fi; sleep 3; done\",
              \"echo '── Pull app image ──'\",
              \"docker pull ${IMAGE}\",
              \"echo '── Start app ──'\",
              \"cd ${HOME_DIR}/alphawonders\",
              \"docker compose up -d\",
              \"echo 'Waiting for app...'\",
              \"for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24; do if docker inspect --format='{{.State.Health.Status}}' alphawonders-app 2>/dev/null | grep -q healthy; then echo 'App healthy!'; break; fi; sleep 5; done\",
              \"echo ''\",
              \"docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'\"
            ]" \
            --output text --query 'Command.CommandId')

          echo "SSM Command ID: $COMMAND_ID"
          echo "Waiting for setup to complete..."
          for i in $(seq 1 120); do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query Status --output text 2>/dev/null || echo "Pending")
            if [ "$STATUS" != "InProgress" ] && [ "$STATUS" != "Pending" ]; then
              break
            fi
            echo "  [$i/120] Status: $STATUS"
            sleep 5
          done

          RESULT=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --output json)
          STATUS=$(echo "$RESULT" | jq -r '.Status')
          echo "Status: $STATUS"
          echo ""
          echo "── stdout ──"
          echo "$RESULT" | jq -r '.StandardOutputContent'

          if [ "$STATUS" != "Success" ]; then
            echo ""
            echo "── stderr ──"
            echo "$RESULT" | jq -r '.StandardErrorContent'
            exit 1
          fi

          echo ""
          echo "=== Server setup complete! ==="
