name: Setup New EC2 Server

# Manual trigger — run once per new server
on:
  workflow_dispatch:
    inputs:
      instance_id:
        description: 'EC2 Instance ID (e.g. i-0be89c6434191eeba)'
        required: true
      deploy_home:
        description: 'Deploy user home dir'
        required: true
        default: '/home/ec2-user'
      pg_user:
        description: 'PostgreSQL username'
        required: true
        default: 'alphawonders'
      pg_db:
        description: 'PostgreSQL database name'
        required: true
        default: 'alphaw'
      pgadmin_email:
        description: 'pgAdmin email'
        required: true
        default: 'mervin@alphawonders.com'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  setup:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # ── Step 1: Store secrets in Parameter Store ──
      - name: Store secrets in SSM Parameter Store
        env:
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
          PG_PASSWORD: ${{ secrets.PG_PASSWORD }}
          PGADMIN_PASSWORD: ${{ secrets.PGADMIN_PASSWORD }}
        run: |
          REGION="${{ secrets.AWS_REGION }}"

          store_param() {
            local name="$1" value="$2" desc="$3" type="${4:-SecureString}"
            if [ -z "$value" ]; then
              echo "WARNING: $name is empty, skipping"
              return
            fi
            aws ssm put-parameter \
              --name "$name" \
              --type "$type" \
              --value "$value" \
              --description "$desc" \
              --region "$REGION" \
              --overwrite
            echo "$name — stored"
          }

          store_param "/deploy/ghcr-pat"         "$GHCR_PAT"                         "GHCR PAT for docker pull"
          store_param "/deploy/pg-user"          "${{ inputs.pg_user }}"              "PostgreSQL username"             String
          store_param "/deploy/pg-password"      "$PG_PASSWORD"                       "PostgreSQL password"
          store_param "/deploy/pg-db"            "${{ inputs.pg_db }}"                "PostgreSQL database name"        String
          store_param "/deploy/pgadmin-email"    "${{ inputs.pgadmin_email }}"        "pgAdmin admin email"             String
          store_param "/deploy/pgadmin-password" "$PGADMIN_PASSWORD"                  "pgAdmin admin password"

      # ── Step 2: Package infra files ──
      - name: Package infra files
        run: |
          tar czf /tmp/infra-bundle.tar.gz \
            infra/docker-compose.postgres.yml \
            infra/nginx/ \
            docker-compose.yml

          BUNDLE=$(base64 -w0 /tmp/infra-bundle.tar.gz)
          echo "BUNDLE_SIZE=$(wc -c < /tmp/infra-bundle.tar.gz)" >> $GITHUB_ENV

          # Split into chunks for SSM (max 24KB per parameter)
          echo "$BUNDLE" > /tmp/bundle.b64
          echo "BUNDLE_B64<<EOFBUNDLE" >> $GITHUB_ENV
          cat /tmp/bundle.b64 >> $GITHUB_ENV
          echo "EOFBUNDLE" >> $GITHUB_ENV

      # ── Step 3: Install Docker + deploy infra via SSM ──
      - name: Install Docker on EC2
        env:
          INSTANCE_ID: ${{ inputs.instance_id }}
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Install Docker" \
            --timeout-seconds 300 \
            --parameters commands="[
              \"set -e\",
              \"if command -v docker &>/dev/null; then echo 'Docker already installed'; docker --version; exit 0; fi\",
              \"echo '── Installing Docker ──'\",
              \"dnf update -y\",
              \"dnf install -y docker\",
              \"systemctl enable --now docker\",
              \"usermod -aG docker ec2-user\",
              \"mkdir -p /usr/local/lib/docker/cli-plugins\",
              \"ARCH=\$(uname -m); if [ \\\"\$ARCH\\\" = 'aarch64' ]; then ARCH='aarch64'; else ARCH='x86_64'; fi\",
              \"curl -SL https://github.com/docker/compose/releases/latest/download/docker-compose-linux-\$ARCH -o /usr/local/lib/docker/cli-plugins/docker-compose\",
              \"chmod +x /usr/local/lib/docker/cli-plugins/docker-compose\",
              \"docker --version\",
              \"docker compose version\"
            ]" \
            --output text --query 'Command.CommandId')

          echo "Command: $COMMAND_ID"
          aws ssm wait command-executed --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" 2>/dev/null || true

          RESULT=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --output json)
          echo "$RESULT" | jq -r '.StandardOutputContent'
          STATUS=$(echo "$RESULT" | jq -r '.Status')
          if [ "$STATUS" != "Success" ]; then
            echo "$RESULT" | jq -r '.StandardErrorContent'
            exit 1
          fi

      - name: Transfer infra files to EC2
        env:
          INSTANCE_ID: ${{ inputs.instance_id }}
          HOME_DIR: ${{ inputs.deploy_home }}
        run: |
          BUNDLE=$(base64 -w0 /tmp/infra-bundle.tar.gz)

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Transfer infra files" \
            --timeout-seconds 120 \
            --parameters commands="[
              \"set -e\",
              \"mkdir -p ${HOME_DIR}/infra ${HOME_DIR}/alphawonders\",
              \"echo '$BUNDLE' | base64 -d > /tmp/infra-bundle.tar.gz\",
              \"tar xzf /tmp/infra-bundle.tar.gz -C /tmp/infra-extract --strip-components=0 2>/dev/null || (mkdir -p /tmp/infra-extract && tar xzf /tmp/infra-bundle.tar.gz -C /tmp/infra-extract)\",
              \"cp -r /tmp/infra-extract/infra/* ${HOME_DIR}/infra/\",
              \"cp /tmp/infra-extract/docker-compose.yml ${HOME_DIR}/alphawonders/docker-compose.yml\",
              \"rm -rf /tmp/infra-bundle.tar.gz /tmp/infra-extract\",
              \"chown -R ec2-user:ec2-user ${HOME_DIR}/infra ${HOME_DIR}/alphawonders\",
              \"echo '── Files deployed ──'\",
              \"ls -la ${HOME_DIR}/infra/\",
              \"ls -la ${HOME_DIR}/infra/nginx/conf.d/\",
              \"ls -la ${HOME_DIR}/alphawonders/\"
            ]" \
            --output text --query 'Command.CommandId')

          echo "Command: $COMMAND_ID"
          aws ssm wait command-executed --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" 2>/dev/null || true

          RESULT=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --output json)
          echo "$RESULT" | jq -r '.StandardOutputContent'
          STATUS=$(echo "$RESULT" | jq -r '.Status')
          if [ "$STATUS" != "Success" ]; then
            echo "$RESULT" | jq -r '.StandardErrorContent'
            exit 1
          fi

      # ── Step 4: Start everything ──
      - name: Start infrastructure and app
        env:
          INSTANCE_ID: ${{ inputs.instance_id }}
          HOME_DIR: ${{ inputs.deploy_home }}
          IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Start infra + app" \
            --timeout-seconds 600 \
            --parameters commands="[
              \"set -e\",
              \"REGION=\$(curl -s http://169.254.169.254/latest/meta-data/placement/region)\",
              \"get_param() { aws ssm get-parameter --name \\\"\$1\\\" --with-decryption --query Parameter.Value --output text --region \\\"\$REGION\\\" 2>/dev/null || echo \\\"\${2:-}\\\"; }\",
              \"echo '── GHCR login ──'\",
              \"GHCR_PAT=\$(get_param /deploy/ghcr-pat)\",
              \"if [ -n \\\"\$GHCR_PAT\\\" ]; then echo \\\"\$GHCR_PAT\\\" | docker login ghcr.io -u deploy --password-stdin; fi\",
              \"echo '── Load secrets ──'\",
              \"export PG_USER=\$(get_param /deploy/pg-user alphawonders)\",
              \"export PG_PASSWORD=\$(get_param /deploy/pg-password)\",
              \"export PG_DB=\$(get_param /deploy/pg-db alphaw)\",
              \"export PGADMIN_EMAIL=\$(get_param /deploy/pgadmin-email admin@alphawonders.com)\",
              \"export PGADMIN_PASSWORD=\$(get_param /deploy/pgadmin-password changeme)\",
              \"export DB_USERNAME=\$PG_USER\",
              \"export DB_PASSWORD=\$PG_PASSWORD\",
              \"export DB_DATABASE=\$PG_DB\",
              \"echo '── Start PostgreSQL + Nginx ──'\",
              \"cd ${HOME_DIR}/infra\",
              \"docker compose -f docker-compose.postgres.yml up -d\",
              \"echo 'Waiting for PostgreSQL...'\",
              \"for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30; do if docker inspect --format='{{.State.Health.Status}}' postgres 2>/dev/null | grep -q healthy; then echo 'PostgreSQL healthy!'; break; fi; sleep 3; done\",
              \"echo '── Pull app image ──'\",
              \"docker pull ${IMAGE}\",
              \"echo '── Start app ──'\",
              \"cd ${HOME_DIR}/alphawonders\",
              \"docker compose up -d\",
              \"echo 'Waiting for app...'\",
              \"for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24; do if docker inspect --format='{{.State.Health.Status}}' alphawonders-app 2>/dev/null | grep -q healthy; then echo 'App healthy!'; break; fi; sleep 5; done\",
              \"echo ''\",
              \"docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'\"
            ]" \
            --output text --query 'Command.CommandId')

          echo "Command: $COMMAND_ID"
          echo "Waiting for setup to complete..."
          aws ssm wait command-executed --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" 2>/dev/null || true

          RESULT=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --output json)
          STATUS=$(echo "$RESULT" | jq -r '.Status')
          echo "Status: $STATUS"
          echo ""
          echo "── stdout ──"
          echo "$RESULT" | jq -r '.StandardOutputContent'

          if [ "$STATUS" != "Success" ]; then
            echo ""
            echo "── stderr ──"
            echo "$RESULT" | jq -r '.StandardErrorContent'
            exit 1
          fi

          echo ""
          echo "=== Server setup complete! ==="
          echo ""
          echo "Next steps:"
          echo "  1. ACM cert (us-east-1) for your domains"
          echo "  2. CloudFront distribution → EC2:80"
          echo "  3. DNS CNAMEs → CloudFront"
          echo "  4. Lock Security Group port 80 to CloudFront prefix list"
